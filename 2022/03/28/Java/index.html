<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="TPCAD">
    
    <title>
        
            Java |
        
        Eulamber
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/pyro.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#FF0000","avatar":"https://s1.ax1x.com/2022/03/09/bReWXd.png","favicon":"/images/pyro.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"愿热情在风中永不熄灭"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Eulamber
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Java</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="https://s1.ax1x.com/2022/03/09/bReWXd.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">TPCAD</span>
                        
                            <span class="author-label">厨力满满的安柏厨</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-03-28 12:03:00</span>
        <span class="mobile">2022-03-28 12:03</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/note/">note</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Java/">Java</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="Java-Note"><a href="#Java-Note" class="headerlink" title="Java Note"></a>Java Note</h1><h2 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>官网 <a class="link"   target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/downloads/" >https://www.oracle.com/java/technologies/downloads/<i class="fas fa-external-link-alt"></i></a></p>
<p>选择 x64 Compressed Archive</p>
<p>可能需要登陆才能进行下载</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>解压下载到的压缩包即可</p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>在 .bashrc 或 .zshrc 中添加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=&lt;jdk 地址&gt;</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p>使变量马上生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>检查是否成功，若出现版本号则安装成功</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java --version</span><br></pre></td></tr></table></figure>

<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>Java 中有以下几种整数类型</p>
<ul>
<li><p>byte 字节型（8 bits，1 字节） 范围：-128 ~ 127</p>
</li>
<li><p>short 短整型（16 bits，2 字节） 范围：-32768 ~ 32767</p>
</li>
<li><p>int 整型（32 bits，4 字节） 范围：-2,147,483,648 ~ 2,147,483,647</p>
</li>
<li><p>long 长整型（64 bits，8 字节） 范围：-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807</p>
<p>长整型在定义时需要在数字后添加 l 或 L</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">125</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">32145</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">50000</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10000000000l</span>;</span><br></pre></td></tr></table></figure>

<p>当 long 也无法表示时可以使用 <code>BigInteger</code> 对象来表示</p>
<p>当整数达到最大值时，再继续增大会回到该类型的最小值</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">a = a + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//输出 a 的结果为 -128</span></span><br></pre></td></tr></table></figure>

<p>整数可以用其他进制表示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//八进制</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">017</span>;</span><br><span class="line"><span class="comment">//十六进制</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0xf</span>;</span><br></pre></td></tr></table></figure>

<h3 id="字符类型和字符串"><a href="#字符类型和字符串" class="headerlink" title="字符类型和字符串"></a>字符类型和字符串</h3><h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>char 字符型（16 bits，2 字节）范围：0 ~ 65535（没有负数）</p>
<p>Java 采用 Unicode 编码，包含了 ASCII 编码</p>
<p>字符用<strong>单引号</strong>定义</p>
<p>如：’a’、’#’、’嘿’ 等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">v</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">h</span> <span class="operator">=</span> <span class="string">&#x27;嘿&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&#x27;$&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Java 中的字符串是一个<strong>类</strong>，用<strong>双引号</strong>定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;balabala&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h3><ul>
<li>float 单精度浮点数型（32 bits，4 字节）</li>
<li>double 双精度浮点数（64 bits，8 字节）</li>
</ul>
<p>Java 中的小数数字默认都 double 类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>

<p>像上面这样声明是错误的，因为 Java 把小数都当作 double 类型，把 double 类型赋值给 float 类型会发生错误。可以用如下方式声明 float 变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="type">float</span>) <span class="number">3.14</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3.14f</span>;</span><br></pre></td></tr></table></figure>

<p>当精度无法满足时，可以使用 BigDecimal 类来进行高精度计算</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型（boolean）只有两个值：</p>
<ul>
<li>true：真</li>
<li>false：假</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>隐式类型转换可以将字节数小的类型转换为字节数小的类型，有以下规律</p>
<p>byte -&gt; short(char) -&gt; int -&gt; long -&gt; float -&gt; double</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//下面每一次赋值都进行了一次隐式类型转换</span></span><br><span class="line"><span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> b;</span><br><span class="line"><span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> c;</span><br><span class="line"><span class="comment">//这样声明 float 变量是可以的</span></span><br><span class="line"><span class="type">float</span> <span class="variable">e</span> <span class="operator">=</span> d;</span><br><span class="line"><span class="type">double</span> <span class="variable">f</span> <span class="operator">=</span> e;</span><br></pre></td></tr></table></figure>

<h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><p>也叫强制类型转换，转换过程可能会出现精度丢失</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">233</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) a;</span><br></pre></td></tr></table></figure>

<h4 id="数据类型自动提升"><a href="#数据类型自动提升" class="headerlink" title="数据类型自动提升"></a>数据类型自动提升</h4><p>在参与运算时（自加自减除外），所有的 byte、short、char 类型都会被自动提升为 int 类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">102</span>;</span><br><span class="line"><span class="comment">/*下面的语句是错误的，应为 a 会被自动提升为 int 类型，</span></span><br><span class="line"><span class="comment">  运算结果也是 int 类型，不能被赋值给 a</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">a = a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<img src="https://s1.ax1x.com/2022/03/09/b22txK.png" alt="数据类型自动提升" style="zoom:50%;" />

<p>这种特性是由<strong>Java虚拟机规范</strong>定义的，类似特性还有</p>
<ul>
<li>如果一个操作数是 long 型，计算结果就是 long 型</li>
<li>如果一个操作数是 float 型，计算结果就是 float 型</li>
<li>如果一个操作数是 double 型，计算结果就是 double 型</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="赋值运算符和算术运算符"><a href="#赋值运算符和算术运算符" class="headerlink" title="赋值运算符和算术运算符"></a>赋值运算符和算术运算符</h3><p>赋值运算符 <code>=</code>，把右边的值赋给左边</p>
<p>算术运算符 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code></p>
<p><code>+</code> 还可以用来连接字符串</p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul>
<li>大于：<code>&gt;</code></li>
<li>小于：<code>&lt;</code></li>
<li>等于：<code>==</code></li>
<li>不等于：<code>!=</code></li>
</ul>
<p>关系运算符的返回值是真或假</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul>
<li>逻辑与：<code>&amp;&amp;</code></li>
<li>逻辑或：<code>||</code></li>
<li>逻辑非：<code>!</code></li>
</ul>
<p>逻辑与和逻辑或都有短路运算的性质。</p>
<p>只要前一个表达式满足条件，就会跳过后一个表达式直接返回结果</p>
<h3 id="按位运算符"><a href="#按位运算符" class="headerlink" title="按位运算符"></a><del>按位运算符</del></h3><ul>
<li><del>按位与：<code>&amp;</code></del></li>
<li>xxxxxxxxxx sudo apt show bash</li>
<li><del>按位异或：<code>^</code></del></li>
<li><del>按位非：<code>~</code></del></li>
</ul>
<h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a &gt; b ? a : b;</span><br><span class="line"><span class="comment">//如果 a &gt; b，将 a 的值赋给 result，若否，将 b 的值赋给 result</span></span><br></pre></td></tr></table></figure>

<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断条件)&#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嵌套 if 语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (条件<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (判断主体) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断主体满足某个 case 条件时就会直接执行对应的代码</p>
<p><code>break</code> 用于跳出 switch，若没有 <code>break</code>，程序会一直执行，直到遇到 <code>break</code> 或 执行完 <code>default</code> 的语句</p>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始条件; 循环条件; 更新) &#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始条件：循环开始前会执行</li>
<li>循环条件：每轮循环开始前会进行一次判断，满足就执行，不满足就结束循环</li>
<li>更新：每轮循环结束后会执行</li>
</ul>
<p>三个条件都不是必须的，甚至可以都不写</p>
<h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (循环条件) &#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 for 循环类似，满足循环条件就会一直执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125; <span class="keyword">while</span>(循环条件);</span><br></pre></td></tr></table></figure>

<p>do-while 循环会先执行一遍再判断是否符合循环条件</p>
<p>结尾有一个 <code>;</code></p>
<h3 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h3><p><code>break</code> <strong>跳出</strong>当前块</p>
<p><code>continue</code> <strong>跳过</strong>当前块</p>
<h2 id="类的基本结构"><a href="#类的基本结构" class="headerlink" title="类的基本结构"></a>类的基本结构</h2><p>面向对象程序设计（Object-Oriented Programming，OOP）</p>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p><strong>类</strong></p>
<p>类（class）是构造对象的模板。它描述一类事物的行为和状态。</p>
<p><strong>对象</strong></p>
<p>对象是类的实例。</p>
<p>假设有一个月饼模具，那么该模具就是一个类。而通过该模具制作出来的月饼就是对象。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>使用 <code>class</code> 关键字创建一个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码创建了一个 <code>Worker</code> 类。类描述了一类事物的行为和状态。下面在该类中定义这些行为和状态。</p>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>成员变量，与叫成员属性、成员字段。用于描述事物的状态或属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>Worker</code> 类中，<code>name</code>、<code>age</code>、<code>salary</code> 都是它的成员变量。</p>
<p>对象可以通过 <code>.</code> 访问其成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Worker</span> <span class="variable">Lisi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line"></span><br><span class="line">LiSi.name = <span class="string">&quot;LiSi&quot;</span>;</span><br><span class="line">LiSi.age = <span class="number">38</span>;</span><br><span class="line">LiSi.salary = <span class="number">9000</span>;</span><br></pre></td></tr></table></figure>

<h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><p>方法类似于 C 中的函数。用于描述事物的行为。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;返回类型&gt; &lt;方法名&gt; ([参数]) &#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    <span class="keyword">return</span> &lt;返回值&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象可以通过 <code>.</code> 使用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">outputName</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LiSi.outputName();</span><br><span class="line"></span><br><span class="line">$ LiSi</span><br></pre></td></tr></table></figure>

<h5 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h5><p>在一个类中，可以出现<strong>同名</strong>但<strong>不同参数类型</strong>的方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">add</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">addTwoNum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> <span class="title function_">addTwoNum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 的这种特性叫<strong>方法的重载</strong></p>
<p>同名方法只根据方法的参数类型进行区分。<strong>与返回值，参数名无关</strong>。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="对象变量"><a href="#对象变量" class="headerlink" title="对象变量"></a><strong>对象变量</strong></h4><p>对象变量是引用类型变量，用来存储对象的地址。声明方法和基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整型变量</span></span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="comment">//对象变量</span></span><br><span class="line">Worker zhangsan;</span><br></pre></td></tr></table></figure>

<p>区分对象变量与对象。<strong>对象变量不是对象</strong>。两者的关系类似 C 中的指针变量与指针。对象变量存储对象的地址，而不是对象本身。</p>
<p>有了对象变量之后就可以创建对象了。在 Java 中，使用 <code>new</code> 来创建一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br></pre></td></tr></table></figure>

<p>上方的语句会返回一个对象。可以将它赋给对应的对象变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Worker</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br></pre></td></tr></table></figure>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>上文中的 <code>Worker()</code> 是构造方法，Java 通过构造方法来创建一个对象。</p>
<p>在 IDEA 中对 <code>.class</code> 文件进行反编译后可以看到如下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Worker.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反编译后的 Worker.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">()</span> &#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到反编译后的 <code>.class</code> 文件中有一个没有返回值，与类同名的方法。</p>
<p>这个方法就是<strong>构造方法</strong>。</p>
<p>当类被创建时，构造方法用来初始化对象。在定义类时<strong>不需要显式定义构造方法</strong>，Java 会自动创建一个<strong>默认的无参构造方法</strong>。创建对象时 <code>new</code> 操作符后面跟着的就是一个构造方法</p>
<p><strong>构造方法的方法名和权限修饰符与类相同</strong>。构造方法<strong>没有返回值</strong>，但它默认返回一个对象。</p>
<p>一旦自定义了构造方法，默认的构造方法就会被覆盖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String i)</span> &#123;</span><br><span class="line">        name = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用有参构造方法创建对象</span></span><br><span class="line"><span class="type">Worker</span> <span class="variable">ZhangSan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;ZhangSan&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果既想要无参构造方法，又想要无参构造方法，可以利用方法的重载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的有参构造方法无法给类的成员变量赋值。如果要使用同名变量，可以使用 <code>this</code> 关键字。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>this</code> 关键字就可以在使用同名变量的同时将值赋给成员变量。</p>
<h4 id="访问对象的变量和方法"><a href="#访问对象的变量和方法" class="headerlink" title="访问对象的变量和方法"></a>访问对象的变量和方法</h4><p>创建对象之后便可通过 <code>.</code> 访问其变量和方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> salary;</span><br><span class="line">    <span class="comment">//无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name, <span class="type">int</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Working!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Worker</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">9990</span>);</span><br><span class="line"><span class="comment">//访问成员变量</span></span><br><span class="line">zhangsan.salary;</span><br><span class="line"><span class="comment">//访问成员方法</span></span><br><span class="line">zhangsan.worker();</span><br></pre></td></tr></table></figure>

<h3 id="静态方法与静态变量"><a href="#静态方法与静态变量" class="headerlink" title="静态方法与静态变量"></a>静态方法与静态变量</h3><p>在类的成员变量或成员方法前加上 <code>static</code> 关键字可以将其设定为<strong>静态变量</strong>或<strong>静态方法</strong>。</p>
<p>静态方法或变量对于这个类是公共的。可以直接通过类名来使用。</p>
<p>例如，下面的例子中，有两个 Worker 对象，ZhangSan 和 LiSi，当通过 LiSi 访问静态变量 salary 并对其修改后，通过 ZhangSan 也能访问到这个修改后的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld!&quot;</span>);</span><br><span class="line">        <span class="type">Worker</span> <span class="variable">ZhangSan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;ZhangSan&quot;</span>);</span><br><span class="line">        Worker LiSi= <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;LiSi&quot;</span>);</span><br><span class="line">        LiSi.salary = <span class="number">5000</span>;</span><br><span class="line">        System.out.println(ZhangSan.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> salary;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而并不推荐通过对象来访问静态成员。对于静态成员，可以直接通过类名来访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Worker.salary = <span class="number">5000</span>;</span><br><span class="line">System.out.println(Worker.salary);</span><br><span class="line">System.out.println(Worker.test());</span><br></pre></td></tr></table></figure>

<p>当一个<strong>类被加载</strong>时，它的静态变量和静态方法会被先加载。这要早于构造方法被调用。</p>
<h3 id="代码块与静态代码块"><a href="#代码块与静态代码块" class="headerlink" title="代码块与静态代码块"></a>代码块与静态代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在对象创建时执行！&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码块</strong>会在<strong>对象被创建时</strong>执行，比构造方法要早。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在对象创建时执行！&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态代码块会在<strong>类被加载时</strong>执行。</p>
<p>执行顺序：静态代码块 &gt; 代码块 &gt; 构造方法</p>
<h2 id="包和访问控制"><a href="#包和访问控制" class="headerlink" title="包和访问控制"></a>包和访问控制</h2><h3 id="包声明和导入"><a href="#包声明和导入" class="headerlink" title="包声明和导入"></a>包声明和导入</h3><p>包其实就是文件夹。可以用来分类 java 文件，区分位置。</p>
<p>包通过 <code>.</code> 分隔路径。如：<code>main.student</code>。</p>
<p>包名应用全小写。</p>
<p>声明文件所在的包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.student;</span><br></pre></td></tr></table></figure>

<p>如果需要使用其他包的类，可以使用 <code>import</code> 关键字进行导入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> main.student.Student;</span><br></pre></td></tr></table></figure>

<p><code>*</code> 可导入包下的所有类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> main.student.*;</span><br></pre></td></tr></table></figure>

<p>Java 会默认导入以下包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.*;</span><br></pre></td></tr></table></figure>

<h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h3><p>静态导入可以直接导入某个类的静态方法或变量。</p>
<p><strong>导入的静态方法或变量的权限需为 <code>public</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> worker.Worker.ab; <span class="comment">// ab 是 Worker 中的一个静态方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> worker.Worker.a; <span class="comment">// a 是 Worker 中的一个静态变量</span></span><br></pre></td></tr></table></figure>

<p>导入后可直接使用，不需要通过类名来访问。</p>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>Java 中可以使用<strong>访问修饰符</strong>来控制类、变量、方法的访问</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同一包内</th>
<th>同一包内子类</th>
<th>不同包子类</th>
<th>其他包</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>protectde</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y&#x2F;N</td>
<td>N</td>
</tr>
<tr>
<td>default</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>private</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
<ul>
<li>default</li>
</ul>
<p>默认访问修饰符。不加任何访问修饰符即使用该修饰符。</p>
<ul>
<li>private</li>
</ul>
<p>私有访问修饰符。最严格的访问修饰符，只允许所在类访问。其他类想要访问只能通过其所在类的公共方法访问。</p>
<ul>
<li>public</li>
</ul>
<p>公有访问修饰符。可以被任何其他类访问。</p>
<ul>
<li>protected</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是相同类型数据的集合（包括引用类型和基本类型）。数组本身是一个类。</p>
<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>线性排列的数据。</p>
<img src="https://s1.ax1x.com/2022/04/09/LF9ii6.png" alt="一维数组" style="zoom:50%;" />

<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>数组通过索引来访问每一个元素。索引从 0 开始。如图中下方所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] num = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">45</span>, <span class="number">65</span>, <span class="number">89</span>&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(num[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">$ <span class="number">65</span></span><br></pre></td></tr></table></figure>

<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">类型[] &lt;变量名&gt; = <span class="keyword">new</span> 类型[大小];</span><br><span class="line"><span class="type">int</span>[] number = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>];</span><br><span class="line"><span class="type">char</span>[] alpha = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">类型 &lt;变量名&gt;[] = <span class="keyword">new</span> 类型[大小]; <span class="comment">// 与 C 类似</span></span><br><span class="line"><span class="type">int</span> num[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>];</span><br></pre></td></tr></table></figure>

<p>在声明数组之后可以用 <code>&#123;&#125;</code> 对数组初始化。</p>
<p>使用下面方式初始化数组时，不能指定数组大小，Java会自动根据 <code>&#123;&#125;</code> 内的元素个数确定数组大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>使用下面方法初始化数组时，必须在声明之后紧接初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] num = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">44</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这样是不合法的。</span></span><br><span class="line"><span class="type">int</span>[] num;</span><br><span class="line">num = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">44</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h4><ul>
<li>数组长度一旦确定后便不可修改</li>
<li>数组元素有默认值。<ul>
<li>int：0</li>
<li>double：0.0</li>
<li>char：’ ‘（空格）</li>
<li>String：NULL</li>
</ul>
</li>
<li>可以通过 <code>length</code> 方法确定获取长度</li>
</ul>
<h4 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h4><p>foreach 循环可以方便地遍历数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] num = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : num) &#123;</span><br><span class="line">    System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组即数组的数组，二维数组的每一个元素都是一个数组。</p>
<img src="https://s1.ax1x.com/2022/04/09/LFCp6g.png" alt="二维数组" style="zoom:50%;" />

<p>二维数组需要两个索引来访问元素，行索引和列索引。Java 采用行优先，即先定位行，在定位列。</p>
<h4 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h4><p>声明与一维数组类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] num = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] num = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>如上所说，二维数组需要两个索引来才能访问元素。</p>
<p>如：<code>num[2][3]</code> 表示第 2 行，第 3 列的元素（索引从 0 开始）。</p>
<h4 id="foreach-循环-1"><a href="#foreach-循环-1" class="headerlink" title="foreach 循环"></a>foreach 循环</h4><p>foreach 循环同样可以遍历二维数组，但需要通过嵌套进行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] i : num) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j : i) &#123;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>多维数组与二维数组类似，不多赘述。</p>
<h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>当方法的参数不确定时，可以使用可变长参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>... num)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">test(<span class="number">3</span>);</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>在变量类型后加上 <code>...</code> 就可以表示方法的形参是可变长参数。实质上 Java 会在调用时将参数<strong>打包成数组</strong>。也就是将参数存到一个名为 <code>num</code> 的数组中。</p>
<p>每个方法只能有一个可变长参数，且只能放在末尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样写是错误的</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i, <span class="type">double</span>... arr, <span class="type">int</span> a)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可变长参数只能放在最后，且只有一个</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> a, <span class="type">double</span>... arr)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管可变长参数本质上是个数组，但不能用 <code>[]</code> 代替 <code>...</code>。</p>
<h3 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h3><h4 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h4><p>冒泡排序走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://visualgo.net/zh/sorting?slide=1" >可视化过程 <i class="fas fa-external-link-alt"></i></a>可以在这里查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">43</span>, <span class="number">16</span>, <span class="number">40</span>, <span class="number">14</span>, <span class="number">34</span>, <span class="number">89</span>, <span class="number">63</span>, <span class="number">33</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length - i - <span class="number">1</span>; j += <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[j] &lt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">			a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">			a[j+<span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出排序后数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : a) &#123;</span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://s1.ax1x.com/2022/04/10/LkzYes.png" alt="LkzYes.png" border="0" style="zoom:50%"/>

<p>如上图，橙色为经过三轮外层循环后排序好的三个数，绿色为正在进行内层循环的两个两个数。</p>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>一般情况下，数组有多少个数就应进行多少次外层循环。但有时候在几次循环后数组即完成排序，这时后面的循环都是多余的。可以在内层循环结束后进行一次判断，若没有发生交换则表明排序已完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length - i - <span class="number">1</span>; j += <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[j] &lt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            sign = <span class="literal">false</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">			a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">			a[j+<span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">    <span class="comment">//内层循环结束后进行判断</span></span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><strong>插入排序</strong>从第二个元素开始，“提取”该元素，将该元素与它前面的元素逐个比较，找到合适的位置，将其插入。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://visualgo.net/zh/sorting?slide=1" >可视化过程 <i class="fas fa-external-link-alt"></i></a>可以在这里查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">45</span>, <span class="number">43</span>, <span class="number">16</span>, <span class="number">40</span>, <span class="number">14</span>, <span class="number">34</span>, <span class="number">89</span>, <span class="number">63</span>, <span class="number">33</span>, <span class="number">2</span>&#125;;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// “提取”元素</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">    <span class="comment">// 被提取元素的前一个元素的索引</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 被提取元素若大于前一元素，前一元素覆盖其后的元素，j&gt;=0 防止数组越界</span></span><br><span class="line">	<span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; temp&gt;a[j]) &#123;</span><br><span class="line">        <span class="comment">// 前一元素覆盖后一元素</span></span><br><span class="line">		a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">		j -= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	a[j+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><strong>选择排序</strong>遍历数组，找到最小（大）的元素，将它放到数组前面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; a.length; j += <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[j] &gt; a[max]) &#123;</span><br><span class="line">			max = j;					</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">			a[i] = a[max];</span><br><span class="line">			a[max] = temp;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象进阶"><a href="#面向对象进阶" class="headerlink" title="面向对象进阶"></a>面向对象进阶</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是面向对象编程三大特点之一。</p>
<p>封装将数据和行为隐藏起来，使用者只能通过特定的方法与数据进行交互。</p>
<h4 id="实现封装"><a href="#实现封装" class="headerlink" title="实现封装"></a>实现封装</h4><ol>
<li>使用 <code>private</code> 修饰符使外部无法直接访问类的成员变量</li>
<li>定义特定的方法使外部可以间接访问类的成员变量</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使外部无法直接访问成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公共的 getter 方法使外部可以获取成员变量</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公共的 setter 方法使外部可以设置成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是面向对象编程三大特性之一。</p>
<p>使用 <code>extends</code> 关键是来实现继承。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类<strong>继承</strong>父类的<strong>所有</strong>成员，但只能<strong>使用</strong>父类的<strong>非私有</strong>成员。</p>
<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><p>当父类的构造方法只有无参构造方法时，无需在子类中显式声明构造方法。</p>
<p>当父类的构造方法为有参构造方法，且子类需要调用该构造方法时，需要在子类中通过 <code>super</code> 关键字显式实现父类的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父类的有参构造方法</span></span><br><span class="line">    <span class="built_in">super</span>(name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类只能使用父类的构造方法，不能自定义自己的构造方法。</p>
<h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><p>子类可以<strong>使用父类的非私有成员变量</strong>。</p>
<p>子类可以定义与父类成员变量同名的成员变量（可以不同类型）。</p>
<p>当定义了同名变量后，默认访问的就是子类的成员变量，反之则是父类的成员变量。此时访问父类的成员变量需要用 <code>super</code> 关键字。</p>
<h4 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h4><p>子类可以<strong>使用父类的非私有成员方法</strong>。</p>
<h5 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h5><p>子类同样可以定义与父类成员方法同名的成员方法，以自己的方式实现父类的某一行为。这成为<strong>方法重写</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Override Method&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重写方法与被重写方法的<strong>参数列表必须完全相同</strong></li>
<li>返回值类型可以不同，但必须是父类返回值的派生类型</li>
<li>静态方法不能被重写</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。比如，动物有叫声，但每个动物的叫声各不相同。叫声就具有多态的性质。</p>
<h4 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h4><h5 id="方法的重写-1"><a href="#方法的重写-1" class="headerlink" title="方法的重写"></a>方法的重写</h5><p>方法的重写是实现多态的一种方式。父类定义的方法在不同的子类中被重写，从而使同一个方法有了不同的实现方式。</p>
<h5 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SportStudent</span>();</span><br></pre></td></tr></table></figure>

<p>在上方的代码中，将一个 <code>SportStudent</code> 对象赋给了 <code>Student</code> 对象变量，其中 <code>SportStudent</code> 是 <code>Student</code> 的子类。这便是<strong>向上转型</strong>，父类对象变量引用子类对象实例。</p>
<p>经过向上转型后的对象变量只能使用父类原有的变量和方法。若子类对父类的方法进行了重写，那该变量<strong>调用的则是重写后的方法</strong>。</p>
<p>经过向上转型的对象变量想要恢复原来的类型可以使用<strong>强制类型转换</strong>进行<strong>向下转型</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SportStudent</span> <span class="variable">sp</span> <span class="operator">=</span> (SportStudent)student;</span><br></pre></td></tr></table></figure>

<p><strong>只有经过向上转型才能进行向下转型。</strong></p>
<h6 id="转型的应用"><a href="#转型的应用" class="headerlink" title="转型的应用"></a>转型的应用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test(Student student) &#123;</span><br><span class="line">    <span class="keyword">if</span> (student <span class="keyword">instanceof</span> SportStudent) &#123;</span><br><span class="line">        <span class="type">SportStudent</span> <span class="variable">sp</span> <span class="operator">=</span> (SportStudent)student;</span><br><span class="line">        SportStudent.exercise();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (student <span class="keyword">instanceof</span> ArtStudent) &#123;</span><br><span class="line">        <span class="type">ArtStudent</span> <span class="variable">ar</span> <span class="operator">=</span> (ArtStudent)student;</span><br><span class="line">        ArtStudent.art();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>instanceof</code></strong> 关键字可以判断两个类的关系。若左边的类是右边的类本身及其派生类则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>上方的函数接受一个 <code>Student</code> 类，但也可以是它的子类。若实参是 <code>Student</code> 的子类，则会先进行向上转型，在通过 <code>instanceof</code> 判断实际类型。</p>
<p>使用 <code>instanceof</code> 时，可以直接进行向下转型。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (student <span class="keyword">instanceof</span> SportStudent a)</span><br></pre></td></tr></table></figure>

<h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><ul>
<li><code>final</code> 修饰类时，该类不能被继承</li>
<li><code>final</code> 修饰成员方法时，该方法不能被重写</li>
<li><code>final</code> 修饰成员变量时，该成员变量必须在构造方法或定义时赋初始值，且不能在修改</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是比类更抽象的类，只保留事物的特征，而不关心如何呈现。</p>
<p>使用 <code>abstract</code> 声明抽象类。抽象类只需定义抽象方法，而不需要实现它（即定义无方法体的方法）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">howl</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>抽象类的子类必须实现其父类的抽象方法（除非子类也是抽象类）</p>
</li>
<li><p>抽象类不能用 <code>new</code> 关键字创建实例</p>
</li>
<li><p>抽象类可以有普通成员变量和方法</p>
</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口比抽象类还要抽象，它只包涵某种方法的定义。</p>
<p>使用 <code>interface</code> 定义接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Eat</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中的方法默认都是公共的抽象方法（即默认被 <code>public</code> 和 <code>abstract</code> 修饰）</p>
<p>接口中的变量默认都是公共的静态常量（即默认被 <code>public</code>、<code>static</code> 和 <code>final</code> 修饰）</p>
<p><strong>一个类可以实现多个接口</strong></p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>在 Java 中，可以在一个类的内部定义另一个类，这种类称为<strong>内部类</strong></p>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>成员内部类与类的成员变量变量类似。</p>
<p>成员内部类可以访问外部类成员，包括私有成员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> out;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">in</span> <span class="operator">=</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有在外部类实例化之后才能创建内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line"><span class="comment">// 创建内部类的语法</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br></pre></td></tr></table></figure>

<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类与静态成员相似。它属于类，与对象无关。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> out;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> an;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">in</span> <span class="operator">=</span> an;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部内可以直接通过类名调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br></pre></td></tr></table></figure>

<p>静态内部类只能访问外部类中的静态成员。</p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类在 new 的时候直接实现接口或抽象类的方法，而不需要先创建一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建匿名内部类</span></span><br><span class="line">        <span class="type">Eat</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Eat</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Eat&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Eat</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h3><p>Java 将基本类型包装成类，使基本数据类型有了类的功能。</p>
<ul>
<li>byte -&gt; Byte</li>
<li>boolean -&gt; Boolean</li>
<li>short -&gt; Short</li>
<li>char -&gt; Character</li>
<li>int -&gt; Integer</li>
<li>long -&gt; Long</li>
<li>float -&gt; Float</li>
<li>double -&gt; Double</li>
</ul>
<p>包装类型可以像基本数据类型一样进行赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">8.3</span>;</span><br><span class="line">System.out.println(a+b);</span><br></pre></td></tr></table></figure>

<h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h4><p>包装类之所以能像基本类型一样运算，是因为自动装箱与自动拆箱机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>在创建 <code>Integer</code> 对象时实际上执行的是上面的语句。这是自动装箱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.intValue();</span><br></pre></td></tr></table></figure>

<p>在将包装类转换为基本数据类型的时候，实际上执行的是上面的语句。只是自动拆箱。</p>
<h4 id="IntegerCache"><a href="#IntegerCache" class="headerlink" title="IntegerCache"></a>IntegerCache</h4><p>当创建的 Integer 类的值在 -127~128 之间时，JAVA 会使用已缓存好的对象进行赋值。</p>
<p>注意，基本包装类并不能像基本数据类型一样进行比较，只能使用 equals 方法。</p>
<h2 id="Java-异常机制"><a href="#Java-异常机制" class="headerlink" title="Java 异常机制"></a>Java 异常机制</h2><p>当程序运行时出现我们没有考虑到的情况时，就有可能出现异常或错误。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>常见的异常如，数组越界异常，空指针异常等。Java 中的异常也是一个类。所有异常均继承自 <code>Exception</code> 类。</p>
<h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><p>运行时异常在编译时无法感知代码是否出现错误，只有在程序运行后才会知道出不出错。运行时异常均继承自 <code>RuntimeException</code>。</p>
<h4 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h4><p>编译时异常在编译阶段就会暴露出来，若不解决异常则无法通过编译。编译时异常直接继承自 <code>Exception</code></p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>错误比异常更严重……</p>
<p>异常（Exception）和错误（Error）都继承自 <strong>Throwable</strong>。</p>
<h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><p>当程序出现异常时，默认会交给 JVM 进行处理，JVM 发现异常后会立即停止程序，并打印栈追踪信息。当我们希望自己处理异常时，就需要捕获异常。</p>
<p>我们可以使用 try-catch 语句块进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(a / b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 括号里创建了一个异常对象，在 catch 中可以使用该对象的相关方法</span></span><br><span class="line"><span class="keyword">catch</span> (ArrayIndexOutOfBoundsException w) &#123;</span><br><span class="line">    <span class="comment">// printStackTrace 方法可以在控制台输出栈追踪信息（JVM 就是这么做的）</span></span><br><span class="line">    w.printStackTrace();</span><br><span class="line">    System.out.println(<span class="string">&quot;数组越界&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ArithmeticException w) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;除数不能为 0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当程序执行到 <code>try</code> 语句时，若发现异常，则会抛出异常，若 <code>catch</code> 语句中有对应的异常处理，则会执行对应 <code>catch</code> 中的语句。若没有对应的 <code>catch</code> 语句，则会交给 JVM 处理。</p>
<p><code>Exception</code> 类中的 <code>printStackTrace</code> 方法可以在控制台打印异常信息。</p>
<h3 id="finally-关键字"><a href="#finally-关键字" class="headerlink" title="finally 关键字"></a>finally 关键字</h3><p>在 <code>try-catch</code> 代码快后可以加上 <code>finally</code> 代码块。</p>
<p><code>finally</code> 中的代码无论异常发生与否都会执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(a / b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ArrayIndexOutOfBoundsException w) &#123;</span><br><span class="line">    w.printStackTrace();</span><br><span class="line">    System.out.println(<span class="string">&quot;数组越界&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ArithmeticException w) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;除数不能为 0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我都会被执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常的抛出"><a href="#异常的抛出" class="headerlink" title="异常的抛出"></a>异常的抛出</h3><h3 id="throws-关键字"><a href="#throws-关键字" class="headerlink" title="throws 关键字"></a>throws 关键字</h3><p>当不想在方法中处理异常，可以使用 <code>throws</code> 关键字将异常抛出，让调用该方法的上级代码处理该异常。</p>
<p><code>throws</code> 写在方法名之后，用于声明该方法<strong>可能</strong>出现的异常。</p>
<p>使用 <code>throws</code> 抛出异常后，不一定需要对异常进行捕获。</p>
<p>若没有进行捕获，发生异常后，异常会继续向上抛出，当抛至 <code>main</code> 方法时，异常会交由 JVM 进行处理。</p>
<p><code>throws</code> 可以抛出多个异常，异常之间用 <code>,</code> 分隔。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExceptionTest</span> <span class="variable">exceptionTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExceptionTest</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exceptionTest.test(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除数不能为 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;被除数不能为 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionTest</span> &#123;</span><br><span class="line">    <span class="comment">// 该方法可能出现 ArithmeticException 异常</span></span><br><span class="line">    <span class="comment">// 但不在该方法体中进行处理</span></span><br><span class="line">    <span class="comment">// 而是将异常抛出，让调用它的方法进行处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">throws</span> ArithmeticException&#123;</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="throw-关键字"><a href="#throw-关键字" class="headerlink" title="throw 关键字"></a>throw 关键字</h3><p><code>throw</code> 用于主动抛出异常。常用于判断后抛出异常。</p>
<p><code>throw</code> 与 <code>throws</code> 一样，都是将异常向上抛，让调用者处理异常。</p>
<p><code>throw</code> 后接一个 <code>Exception</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExceptionTest</span> <span class="variable">exceptionTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExceptionTest</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exceptionTest.test(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除数不能为 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;被除数不能为 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">// 当条件符合时，主动抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>Java 虽然定义了很多异常类，但实际应用中 Java 中的异常类并不能完全描述各种异常。</p>
<p>可以通过继承的方式创建自定义异常类。</p>
<p><strong>建议继承 <code>RuntimeException</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>)</span><br><span class="line">            	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NameIsNullException</span>(<span class="string">&quot;姓名不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NameIsNullException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常，继承自 RuntimeException</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NameIsNullException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NameIsNullException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NameIsNullException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NameIsNullException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NameIsNullException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在实际开发中，一个属性可以用不同的数据类型表示。如，成绩可以用“优秀”、“良好”等字符串类型来表示，也可以用 88.4、48、80 等整型、浮点型或基本包装类来表示。这为类的编写带来了很大麻烦。</p>
<p>一种方法是将成绩这个属性用 <code>Object</code> 对象表示。如此便能用字符串或基本包装类来表示该属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    Object score;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样会带来一个问题。当我们想要获取并使用该属性时，需要先判断该属性到底是哪一类型，并对其进行强制类型转换，这样会增加很多代码量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Score</span> <span class="variable">scoreOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(<span class="string">&quot;数据结构&quot;</span>， <span class="string">&quot;EP23&quot;</span>, <span class="string">&quot;优秀&quot;</span>);</span><br><span class="line"><span class="type">Score</span> <span class="variable">scoreTwo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(<span class="string">&quot;高等数学&quot;</span>， <span class="string">&quot;EP22&quot;</span>, <span class="number">89</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (scoreOne.score <span class="keyword">instanceof</span> String) <span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> (String)scoreOne.score;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (scoreOne.score <span class="keyword">instanceof</span> Integer) <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> (Integer)scoreOne.score;</span><br></pre></td></tr></table></figure>

<p>因此，JDK 引入泛型的概念。</p>
<h3 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>&lt;T&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    T score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Score&lt;String&gt; scoreOne = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;String&gt;(<span class="string">&quot;数据结构&quot;</span>， <span class="string">&quot;EP23&quot;</span>, <span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">Score&lt;Integer&gt; scoreTwo = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;Integer&gt;(<span class="string">&quot;高等数学&quot;</span>， <span class="string">&quot;EP22&quot;</span>, <span class="number">89</span>);</span><br></pre></td></tr></table></figure>

<p>上面的代码便是一个泛型类。在类名后接 **<code>&lt;T&gt;</code>**（尖括号中的内容不是随意的），表示这是一个泛型类。</p>
<p>而 <code>T score</code> 表示 <code>score</code> 这个属性的类型由用户的输入决定。</p>
<p>在创建泛型类时，在类名后加上对应的类型名。</p>
<h3 id="泛型的本质"><a href="#泛型的本质" class="headerlink" title="泛型的本质"></a>泛型的本质</h3><p>泛型其实是 Java 的一个语法糖。JVM 本身并不支持泛型。在编译阶段，编译器将泛型编译成 JVM 能读懂的代码。其实就是上面提到的第一种方法，使用 Object 类来存储属性，并通过强制类型转换来使用该属性。不同的只是这些工作都交给编译器来完成。</p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>前文的例子便是一个<strong>泛型类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>&lt;T&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    T score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类名后加上 <strong><code>&lt;T&gt;</code></strong> 即可声明一个泛型类。尖括号中的字母是随意的，但有其规范。此处的 <code>T</code> 意为 <code>Type</code>。泛型类一般取一个大写字母。</p>
<p><code>T</code> 被称为<code>参数化类型</code>。一个泛型类中可以有多个参数化类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>&lt;T,D,R&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型类时，必须明确指出其类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;String&gt; math = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>泛型只能用于对象属性，<strong>不能用于类对象</strong>（即静态变量）。</p>
<p>泛型不能用于基本数据类型（与泛型的本质有关）。</p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法与普通方法一样，只不过将数据类型换成了参数化类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>&lt;T&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    T score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(T score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getScore</span><span class="params">(<span class="keyword">void</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法<strong>无法直接使用类定义的泛型</strong>。因为方法在执行前必须明确参数的数据类型，而静态方法不依赖于对象，在对象创建前，即参数化类型还没明确前就可以被执行，所以静态方法不能直接使用类定义的泛型。</p>
<h4 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h4><p>虽然静态方法<strong>无法直接使用类定义的泛型</strong>，但是泛型方法可以使用泛型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，非静态方法也可以这样使用泛型。</p>
<h3 id="泛型引用"><a href="#泛型引用" class="headerlink" title="泛型引用"></a>泛型引用</h3><p>定义泛型引用时，需要在后面指出此类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;String&gt; score;</span><br></pre></td></tr></table></figure>

<p>如果不希望指定类型，或希望引用任意的类型，可以使用通配符 <code>?</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;?&gt; score;</span><br></pre></td></tr></table></figure>

<p>使用通配符后，该成员变量的类型是 Object，因为编译器无法确定准确的类型，只能使用原始类型。</p>
<h3 id="泛型的界限"><a href="#泛型的界限" class="headerlink" title="泛型的界限"></a>泛型的界限</h3><p>可以把泛型的类型限定在某一类型之内。</p>
<h4 id="泛型的上界"><a href="#泛型的上界" class="headerlink" title="泛型的上界"></a>泛型的上界</h4><p>如果只希望 <code>score</code> 是 <code>Number</code> 类型，可以规定泛型的上界。</p>
<p>使用 <code>extends</code> 规定泛型的上界，如此，参数化类型只能是 <code>Number</code> 及其子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    T score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;String&gt; score; <span class="comment">// 编译失败，String 不是 Number 或其子类</span></span><br></pre></td></tr></table></figure>

<p>确定泛型上界后，如果再使用通配符，那么原始类型是 Number。</p>
<h4 id="泛型的下界"><a href="#泛型的下界" class="headerlink" title="泛型的下界"></a>泛型的下界</h4><p>下界与上界相反，设定下界后，参数化类型只能是 <code>Number</code> 及其父类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>&lt;T <span class="built_in">super</span> Number&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    T score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确定泛型下界后，如果再使用通配符，原始类型仍然是 Object。</p>
<h3 id="钻石运算符"><a href="#钻石运算符" class="headerlink" title="钻石运算符"></a>钻石运算符</h3><p>创建泛型对象时，可以不指定类型，直接使用 <code>&lt;&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;String&gt; score = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><del>可能因为 <code>&lt;&gt;</code> 看着像钻石吧</del></p>
<h3 id="泛型与多态"><a href="#泛型与多态" class="headerlink" title="泛型与多态"></a>泛型与多态</h3><p>接口也可以使用泛型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ScoreInterface</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两种实现泛型接口的方式。</p>
<p>不指定泛型类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">ScoreInterface</span>&lt;T&gt; &#123;</span><br><span class="line">    T score;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定泛型类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span> <span class="keyword">implements</span> <span class="title class_">ScoreInterface</span>&lt;String&gt; &#123;</span><br><span class="line">    String score;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多态类型擦除"><a href="#多态类型擦除" class="headerlink" title="多态类型擦除"></a>多态类型擦除</h4><h2 id="Java-I-x2F-O"><a href="#Java-I-x2F-O" class="headerlink" title="Java I&#x2F;O"></a>Java I&#x2F;O</h2><h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><p><strong>绝对路径与相对路径</strong></p>
<p><strong>相对路径</strong>是在当前运行目录下寻找文件；<strong>绝对路径</strong>则是从根目录开始寻找。</p>
<p>路径分隔符支持使用 <code>/</code> 和 <code>\\</code>，但不支持 <code>\</code>。</p>
<p><strong>异常处理</strong></p>
<p>每一种流的构造方法都会抛出 <code>FileNotFoundException</code>，必须对其进行处理。</p>
<p>流在使用完毕后，必须使用 <code>close</code> 方法将其关闭。然而 <code>close</code> 方法也会抛出异常。如此以来代码会变得非常臃肿。JDK 1.7 之后提供了一种简洁的写法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;fileOne.txt&quot;</span>);</span><br><span class="line">     <span class="type">FileOuntputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;fileTwo.txt&quot;</span>)) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>只有实现了 AutoCloseable 接口类才支持该语法。</strong></p>
<p>有个流时，使用 <code>;</code> 进行分隔。</p>
<h4 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a>文件字节流</h4><h5 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><p><strong>FileInputStream</strong> 用于读取文件，每次读取一个字节。</p>
<p><strong>FileInputStream</strong> 使用 <code>read</code> 方法读取文件内容。</p>
<ul>
<li>每次读取一个字节，并返回一个整型</li>
<li>返回的整型是该字节的 Unicode 编码</li>
<li>当读取到文件末尾时，返回 -1</li>
<li>读取到一个字节后，下一次读取会自动读取下个字节，直至末尾</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(inputStream.read());</span><br><span class="line">System.out.println((<span class="type">char</span>)inputStream.read());</span><br><span class="line">$ <span class="number">104</span></span><br><span class="line">$ a</span><br></pre></td></tr></table></figure>

<p>可以使用 while 循环来读取文件整个文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="keyword">while</span> ((temp = inputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">	System.out.print((<span class="type">char</span>)temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 available 方法可以查看当前可读的剩余字节数量（有时候不一定准确）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system.out.println(inputStream.available());</span><br></pre></td></tr></table></figure>

<p><strong>FileInputStream</strong> 还有两种 read 方法。</p>
<p>一次性读取一个字节数组长度的字节数。<strong>返回读取到的字节数</strong>，当读取到文件末尾时，返回 -1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] temp = <span class="keyword">new</span> <span class="title class_">byte</span>[inputStream.available()];</span><br><span class="line">System.out.println(inputStream.read(temp));</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(temp));</span><br><span class="line">$ <span class="number">4</span> <span class="comment">// 读取到的字节数</span></span><br><span class="line">$ haha <span class="comment">//读取到的内容</span></span><br></pre></td></tr></table></figure>

<p>控制读取字节的数量，并从指定位置开始存储。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] temp = <span class="keyword">new</span> <span class="title class_">byte</span>[inputStream.available()];</span><br><span class="line"><span class="comment">//从字节数组 1 号索引开始存储，读取两个字节</span></span><br><span class="line">System.out.println(inputStream.read(temp,<span class="number">1</span>,<span class="number">2</span>)); </span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(temp));</span><br><span class="line">$ <span class="number">2</span> <span class="comment">// 读取到的字节数</span></span><br><span class="line">$  ha  <span class="comment">//读取到的内容</span></span><br></pre></td></tr></table></figure>

<p>使用 skip 方法可以跳过指定数量的字节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] temp = <span class="keyword">new</span> <span class="title class_">byte</span>[inputStream.available()];</span><br><span class="line">inputStream.skip(<span class="number">1</span>);</span><br><span class="line">System.out.println(inputStream.read(temp,<span class="number">1</span>,<span class="number">2</span>)); </span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(temp));</span><br><span class="line">$ <span class="number">2</span> <span class="comment">// 读取到的字节数</span></span><br><span class="line">$  ah  <span class="comment">//读取到的内容</span></span><br></pre></td></tr></table></figure>

<h5 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h5><p><strong>FileOutputStream</strong> 用于写入数据，每次写入一个字节，无返回值。</p>
<p><strong>FileOutputStream</strong> 使用 <code>write</code> 将数据写入文件。与 <code>read</code>方法类似，有三种方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outputStream.write(<span class="number">97</span>); <span class="comment">// 写入一字节。</span></span><br><span class="line">outputStream.write(temp); <span class="comment">// 写入一个字节数组</span></span><br><span class="line">outputStream.write(temp, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">//指定起始位置及长度</span></span><br></pre></td></tr></table></figure>

<p>在完成所有写入操作之后，建议使用 <code>flush</code> 方法进行一次刷新操作（强制写入）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">outputStream.flush();</span><br></pre></td></tr></table></figure>

<p><strong>FileOutputStream</strong> 会先删除文件原有的内容再进行写入，如果不希望删除原有内容，可以使用追加模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是布尔类型，true 表示开启追加模式，默认为 false</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.txt&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h4 id="文件字符流"><a href="#文件字符流" class="headerlink" title="文件字符流"></a>文件字符流</h4><h5 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h5><p><strong>FileReader</strong> 用于读取文件，每次读取一个字符。</p>
<p><strong>FileReader</strong> 的 <code>reader</code> 方法可以读取文件内容，与 <strong>FileInputStream</strong> 类似，但读取单位是字符，同样有三种方式。不多赘述。</p>
<h5 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h5><p><strong>FileWriter</strong> 用于将数据写入文件，每次写入一个字符。</p>
<p><strong>FileWriter</strong> 的 <code>writer</code> 方法可以读取文件内容，与 <strong>FileOutputStream</strong> 类似，但写入单位是字符，同样有三种方式。不多赘述。</p>
<h3 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h3><p>File 类专门用来表示一个<strong>文件或文件夹</strong>，但它并不是这个文件本身。</p>
<p>File 类定义在 <code>java.io.File</code> 中</p>
<p><strong>创建 File 类</strong></p>
<p>可以使用相对路径和绝对路径创建一个 File 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/novel.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>创建 File 对象时，若文件或目录不存在，Java 并不会自动创建该文件或目录（File 不是文件本身）。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><strong>判断文件或目录是否存在</strong></p>
<p>exists 方法可以检测是否存在，返回一个布尔值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">fileOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src&quot;</span>); <span class="comment">// 存在</span></span><br><span class="line"><span class="type">FIle</span> <span class="variable">fileTwo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fi8le</span>(<span class="string">&quot;src/io&quot;</span>); <span class="comment">// 不存在</span></span><br><span class="line"></span><br><span class="line">fileOne.exists();  <span class="comment">// 返回 true</span></span><br><span class="line">fileTwo.exists(); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure>

<p><strong>判断是否为文件&#x2F;目录</strong></p>
<p>isDirectory 方法可以判断 File 所代表的是否为一个目录，返回一个布尔值</p>
<p>isFile 方法可以判断 File 所代表的是否为一个文件，返回一个布尔值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src&quot;</span>);</span><br><span class="line">file.isDirectory(); <span class="comment">// 返回 true</span></span><br><span class="line">file.isFile(); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure>

<p><strong>创建文件&#x2F;目录</strong></p>
<p>当 File 类所代表的目录不存在时，可以使用 mkdir 或 mkdirs 创建该目录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/io&quot;</span>); <span class="comment">// 该目录不存在</span></span><br><span class="line">file.mkdir(); <span class="comment">// 在 src 目录下创建 io 目录，只有当 src 存在时才能成功创建</span></span><br><span class="line"><span class="comment">//file.mkdirs(); 若 src 不存在则会先创建 src，再创建 io</span></span><br></pre></td></tr></table></figure>

<p>当 File 类所代表的文件不存在时，可以使用 createNewFile 创建该文件。该方法会抛出 IOException 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/io/file.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    file.createNewFile();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取文件大小</strong></p>
<p>length 方法可以获取文件或目录的大小。</p>
<p><strong>判断是否可读&#x2F;可写&#x2F;可执行</strong></p>
<p>canRead、canWrite、canExecute 方法可以分别判断是否可读、可写、可执行。均返回一个布尔值</p>
<p><strong>读取目录</strong></p>
<p>当 File 类方法是一个目录时，可以使用 list 方法返回一个包含该目录下所有文件名及目录名的字符串数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">fileOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/file&quot;</span>);</span><br><span class="line">String[] fileName = fileOne.list();</span><br><span class="line"><span class="keyword">for</span> (String s:fileName) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若想返回 File 数组，可以使用 listFiles 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">fileOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/file&quot;</span>);</span><br><span class="line">File[] fileName = fileOne.list();</span><br><span class="line"><span class="keyword">for</span> (File s:fileName) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="字符串进阶"><a href="#字符串进阶" class="headerlink" title="字符串进阶"></a><del>字符串进阶</del></h2><h2 id="JAVA-API"><a href="#JAVA-API" class="headerlink" title="JAVA API"></a><del>JAVA API</del></h2><h3 id="Object-类中的-equals-方法"><a href="#Object-类中的-equals-方法" class="headerlink" title="Object 类中的 equals() 方法"></a><del>Object 类中的 equals() 方法</del></h3><p><del>Object 类中的 equals() 方法接受一个 Object 对象，它可以比较当前类与所接受的实参是否为同一个类（实际比较的是两个对象的地址是否相同），若相同则返回 true。</del></p>
<h3 id="Object-类中的-toString-方法"><a href="#Object-类中的-toString-方法" class="headerlink" title="Object 类中的 toString() 方法"></a><del>Object 类中的 toString() 方法</del></h3><p><del>toString() 方法可以返回一个字符串，这个字符串由 <code>包名</code>.<code>类名</code>@<code>内存地址</code> 组成</del></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(student);</span><br></pre></td></tr></table></figure>

<p><del>上方的代码会默认调用 toString() 方法</del></p>
<h3 id="Random-类"><a href="#Random-类" class="headerlink" title="Random 类"></a><del>Random 类</del></h3><p><del>Random 类需要一个长整型作种子，若不指定则以当前的系统时间作为种子</del></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不指定种子</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="comment">//指定种子</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">13</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><del>nextLine() 生成整数随机数，可指定范围</del></li>
<li><del>nextDouble() 生成浮点数随机数，范围在 0~1 之间</del></li>
</ul>

        </div>

        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/Java/">#Java</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/03/28/Ubuntu/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Ubuntu</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">TPCAD</a>
        </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-Note"><span class="nav-text">Java Note</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85-JDK"><span class="nav-text">安装 JDK</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD"><span class="nav-text">下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-text">安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-text">配置环境变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-text">整数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">字符类型和字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6"><span class="nav-text">字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">字符串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-text">小数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="nav-text">布尔类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">隐式类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">显式类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8D%87"><span class="nav-text">数据类型自动提升</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">赋值运算符和算术运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">关系运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">按位运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">三目运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5"><span class="nav-text">选择语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#if-%E8%AF%AD%E5%8F%A5"><span class="nav-text">if 语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switch-%E8%AF%AD%E5%8F%A5"><span class="nav-text">switch 语句</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-text">循环结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="nav-text">for 循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#while-%E5%BE%AA%E7%8E%AF"><span class="nav-text">while 循环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#break-%E4%B8%8E-continue"><span class="nav-text">break 与 continue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">类的基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-text">类和对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-text">成员方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="nav-text">方法重载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F"><span class="nav-text">对象变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-text">访问对象的变量和方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-text">静态方法与静态变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text">代码块与静态代码块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E5%92%8C%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">包和访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AF%BC%E5%85%A5"><span class="nav-text">包声明和导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5"><span class="nav-text">静态导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-text">访问权限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">一维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-text">索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E"><span class="nav-text">声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7"><span class="nav-text">一些特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#foreach-%E5%BE%AA%E7%8E%AF"><span class="nav-text">foreach 循环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">二维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E-1"><span class="nav-text">声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE"><span class="nav-text">访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#foreach-%E5%BE%AA%E7%8E%AF-1"><span class="nav-text">foreach 循环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">多维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="nav-text">可变长参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="nav-text">排序方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-Bubble-Sort"><span class="nav-text">冒泡排序(Bubble Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%8C%96"><span class="nav-text">优化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">选择排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6"><span class="nav-text">面向对象进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-text">封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%B0%81%E8%A3%85"><span class="nav-text">实现封装</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-1"><span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-1"><span class="nav-text">成员方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="nav-text">方法的重写</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">多态的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99-1"><span class="nav-text">方法的重写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="nav-text">向上转型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BD%AC%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">转型的应用</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">final 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">成员内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">静态内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">匿名内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-text">基本类型包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="nav-text">自动装箱与拆箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IntegerCache"><span class="nav-text">IntegerCache</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6"><span class="nav-text">Java 异常机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="nav-text">运行时异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="nav-text">编译时异常</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF"><span class="nav-text">错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-text">异常的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finally-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">finally 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA"><span class="nav-text">异常的抛出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#throws-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">throws 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#throw-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">throw 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-text">自定义异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B-1"><span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-text">泛型的本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-text">泛型类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-text">泛型方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-text">自定义泛型方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%BC%95%E7%94%A8"><span class="nav-text">泛型引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%95%8C%E9%99%90"><span class="nav-text">泛型的界限</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C"><span class="nav-text">泛型的上界</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8B%E7%95%8C"><span class="nav-text">泛型的下界</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%92%BB%E7%9F%B3%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">钻石运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="nav-text">泛型与多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-text">多态类型擦除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-I-x2F-O"><span class="nav-text">Java I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81"><span class="nav-text">文件流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-text">文件字节流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileInputStream"><span class="nav-text">FileInputStream</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FileOutputStream"><span class="nav-text">FileOutputStream</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-text">文件字符流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileReader"><span class="nav-text">FileReader</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FileWriter"><span class="nav-text">FileWriter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File-%E7%B1%BB"><span class="nav-text">File 类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">常用方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6"><span class="nav-text">字符串进阶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA-API"><span class="nav-text">JAVA API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-%E7%B1%BB%E4%B8%AD%E7%9A%84-equals-%E6%96%B9%E6%B3%95"><span class="nav-text">Object 类中的 equals() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-%E7%B1%BB%E4%B8%AD%E7%9A%84-toString-%E6%96%B9%E6%B3%95"><span class="nav-text">Object 类中的 toString() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Random-%E7%B1%BB"><span class="nav-text">Random 类</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>





    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
